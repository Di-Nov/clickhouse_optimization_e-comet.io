# [e-Comet](https://e-comet.io/ "ссылка на сайт")

<img src="https://hh.ru/employer-logo/3910308.png" style="object-fit: cover; width:20%;" >

> Тестовое задание для компании "LESTA GAMES"

## Содержание

* [Тестовое задание](#test)
* [Технологии](#teh)
* [Использование](#use)
* [Установка](#t)
* [Выводы](#conclusions)
* [feedback](#contr)
* [Команда проекта](#team)

## <h3 id="test">Тестовое задание</h3>

Clickhouse - это крутая высокопроизводительная БД для анализа больших данных. С ней имеет смысл познакомиться, даже если
ты про нее ранее не слышал.

Даны две таблицы в Clickhouse, в каждой из которых по 100 млн+ строк и возможны дубликаты. Каждый день обновляется около
1 млн продуктов (то есть на 2 порядка меньше, чем строк в таблице).

``` SQL
CREATE TABLE IF NOT EXISTS products
(
    product_id   Int32,
    product_name String,
    brand_id     Int32,
    seller_id    Int32,
    updated      Date
)
    ENGINE = ReplacingMergeTree
    ORDER BY product_id;
```

``` SQL
(
    date       Date,
    product_id Int32,
    remainder  Int32,
    price      Int32,
    discount   Int32,
    pics       Int32,
    rating     Int32,
    reviews    Int32,
    new        Bool
)
    ENGINE = ReplacingMergeTree
    ORDER BY (date, product_id);
```

Напиши 3 причины, по которым следующий запрос выполняется медленно (5 секунд) и предложи быструю версию запроса (<0.1
секунды :), без изменений архитектуры таблиц (не надо предлагать "добавить индексы") и дающую такой же результат (без
дубликатов):

'''SELECT DISTINCT product_id
FROM products FINAL
INNER JOIN remainders FINAL USING (product_id)
WHERE (updated = today()) AND (date = (today() - 1))'''

Несколько хинтов:

1. Для первой причины достаточно базового знания чистого SQL (алгоритм фильтрации)
2. Для второй причины достаточно знания отличия SQL JOIN от IN
3. Для третьей причины требуется прочитать про ReplacingMergeTree и про final (15 минут чтения официальной документации
   по Clickhouse)
4. Нейронка или авто-оптимизаторы SQL тут не помогут. Мы хотим проверить НЕ навык промт-энжиниринга, а твою способность
   думать и разбираться в новых вещах. Не словом ("Могу быстро разобраться с чем угодно... но не сейчас"), а делом ;)

## <h3 id="teh">Технологии</h3>

+ docker
+ clickhouse
+ python = 3.11
+ python-dotenv = 1.0.1
+ faker = 25.9.1
+ clickhouse-driver = 0.2.8

## <h3 id="use">Использование</h3>

*В связи с неполной информации тестового задания и неясности понятия "коллекция", параметр IDF выбран случайным
образом.*

## <h3 id="t">Установка</h3>

* Копируем приложение к себе локально git clone https://github.com/Di-Nov/clickhouse_optimization_e-comet.io-.git
* Запускаем через Docker командой `make up` (Данной комеадой запускется база clickhouse, создаются таблицы и загружаются
  тестовые данные)
* Джем окончания загрузки тестовых данных 4 минуты.
* Заходим в контейнер clickhouse `docker exec -it clickhouse clickhouse-client`
* Выполняем базовый запрос:

``` SQL
SELECT DISTINCT product_id
FROM products FINAL
INNER JOIN remainders FINAL USING (product_id)
WHERE (updated = today()) AND (date = (today() - 1));
```

* Выполняем Оптимизированный запрос:

``` SQL
SELECT product_id
FROM products
WHERE (product_id IN ((
    SELECT product_id
    FROM remainders
    WHERE date = yesterday()
) AS remainders_products_id)) AND (updated = today());
```

## <h3 id="conclusions">Выводы</h3>

1) Каждый раз для выполнения запроса с одинаковым JOIN, подзапрос выполняется заново — результат не кэшируется. правая
таблица читается заново при каждом запросе. Поэтому используем вложенный запрос и IN.
Так как clickhouse столбцовая СУБД, нам не нужна информация из других столбцов, достаточно только product_id

2) Запросы, которые используют FINAL выполняются немного медленее, чем аналогичные запросы без него, потому что:

Данные мёржатся во время выполнения запроса в памяти, и это не приводит к физическому мёржу кусков на дисках.
Запросы с модификатором FINAL читают столбцы первичного ключа в дополнение к столбцам, используемым в запросе.
В большинстве случаев избегайте использования FINAL.

- Данные мёржатся во время выполнения запроса в памяти, и это не приводит к физическому мёржу кусков на дисках.
- Запросы с модификатором FINAL читают столбцы первичного ключа в дополнение к столбцам, используемым в запросе.
  В большинстве случаев следует избегать использования FINAL. На тестовой БД запрос выполнился значительно быстрее

## <h3 id="feedback">Обратная связь</h3>

Вы можете дать обратную связь, если у вас будут предложение по улучшению проекта или информация по его дополнению.
Связь по почте novozhilov812@gmail.com или рассмотреть
мою [анкету на hh](https://spb.hh.ru/resume/470b7c08ff0be7838d0039ed1f594f75313234 "ссылка на HH")

## <h3 id="team">Команда проекта</h3>

Новожилов Дмитрий — Backend Engineer <br>
novozhilov812@gmail.com
